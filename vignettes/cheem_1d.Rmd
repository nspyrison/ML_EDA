---
title: "Trees of Cheem 1D"
author: "Nicholas Spyrison"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    theme: united
editor_options: 
  chunk_output_type: console
---
<!--   #rmarkdown::html_vignette -->
<!-- # vignette: > -->
<!-- #   %\VignetteIndexEntry{spinifex} -->
<!-- #   %\VignetteEngine{knitr::rmarkdown} -->
<!-- #   %\VignetteEncoding{UTF-8}{inputenc} -->
<!-- #   \usepackage[utf8]{inputenc} -->

<!-- #Example vignette: 
https://github.com/njtierney/naniar/blob/master/vignettes/getting-started-w-naniar.Rmd -->
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo       = TRUE, ## code
  include    = TRUE, ## plots
  eval       = TRUE, ## chunk
  message    = FALSE,
  warning    = FALSE,
  error      = FALSE,
  collapse   = TRUE,
  cache      = TRUE,
  cache.lazy = FALSE
)
## Set dir relative to package
knitr::opts_knit$set(root.dir = '..')
```

# Trees of Cheem 1D

## Requirements

```{R}
require("DALEX")
#require("treeshap") ## Needed?
require("spinifex")
require("tourr")
require("ggplot2")
## Local functions
source("./apps/poc/trees_of_cheem.r") ## Cheem functions
source("./apps/poc/spinifex_ggproto.r") ## New (spinifex) ggproto_* api
## Not run, open local function files
if(F){
  file.edit("./apps/poc/trees_of_cheem.r")
  file.edit("./apps/poc/spinifex_ggproto.r")
}
```

## Data setup

```{R}
str(tourr::flea) ## 74 x 6 numeric + 3 level class
dat <- spinifex::scale_sd(tourr::flea[, 1:6])
clas <- tourr::flea$species
new_obs <- 20
tgt_var <- clas == clas[new_obs] ## Or regression on a continuous var not in data.
```

## Find a start basis

```{r}
bas_cheem <- basis_cheem(
  data = dat,
  holdout_rownum = new_obs,
  target_var = tgt_var,
  class = clas,
  parts_type = "shap",
  basis_type = NULL)
print(bas_cheem) ## 1 dim

## The 1d shap projection of whole data (with oos obs)
ggplot_tour(bas_cheem, dat) +
  ggproto_basis_axes1d() +
  ggproto_data_density1d_rug(aes_args = list(color = clas, fill = clas))
```


## View a cheem basis

```{r}
#debugonce(ggproto_data_density1d_rug)
#debugonce(plot.cheem_basis)
plot.cheem_basis(cheem_basis = bas_cheem, show_parts = TRUE)
## LAST ERROR:
# Error: Unknown input: function
## rlang::last_error()
#<error/rlang_error>
#Unknown input: function
#Backtrace:
#  1. global::plot.cheem_basis(cheem_basis = bas_cheem, show_parts = TRUE)
#  2. GGally:::`+.gg`(...) ./apps/poc/trees_of_cheem.r:238:2
## ... thru 15
##
## .oos_rug_call, the last item of .ggp_data is a function not a ggplot2 call..., look into that. seems like it's the run for oos obs.
```

# An aside: DALEX::plot.predict_parts() symmetrically robust?

in short, yes.

In the following evaluated R chunk (see code) we permute both the output DALEX::predict_parts columns and that of the input data. Both do not change the print order (though permuting the parts order does destroy the local attribution CI.)

```{r, eval=FALSE}
.parts <- attributes(bas_cheem)$predict_parts
plot(.parts)

## Explore the variable order assyemtry; does var order matter?
colnames(dat) ## 1) plot.predict_parts() doesn't print in variable nor ABC order.
set.seed(1010)
.col_shuffle <- sample(1:6, 6)
# .parts2 <- .parts[.col_shuffle, ] ## 2) shuffling a plot.predict_parts() obj doesn't change the print order (but has destroys the CI of the values.)
print("Shuffling the predict parts obj, obscurses the CI of the local attribution of the shap values, but not the order displayed. what if we shuffle the variables right out of the gate?")

## Setup dat2, with shuffled columns:
dat2 <- spinifex::scale_sd(tourr::flea[, .col_shuffle])
bas_cheem2 <- basis_cheem(
  data = dat2,
  holdout_rownum = new_obs,
  target_var = tgt_var,
  class = clas,
  parts_type = "shap",
  basis_type = NULL)
.parts2 <- attributes(bas_cheem2)$predict_parts

require("patchwork")
plot(.parts) + plot(.parts2)
print("Great! robust to both the varaible order both before and after")
```

