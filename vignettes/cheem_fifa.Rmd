---
title: "Cheem example: FIFA"
author: "Nicholas Spyrison"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    theme: united
editor_options: 
  chunk_output_type: console
---

<!-- #Example vignette: 
https://github.com/njtierney/naniar/blob/master/vignettes/getting-started-w-naniar.Rmd -->
```{r knitr setup, include = FALSE}
knitr::opts_chunk$set(
  echo       = TRUE,   # code
  include    = TRUE,   # plots
  eval       = TRUE,   # chunk
  message    = FALSE,
  warning    = FALSE,
  error      = FALSE,
  collapse   = TRUE,
  cache = TRUE
)
## Set dir relative to package
knitr::opts_knit$set(root.dir = '..')
```

# Example application of Trees of Cheem

Here we start with the intro `trees_of_cheem.rmd` applied to tourr::flea data and set off to apply Cheem functions to DALEX::fifa, 5000 soccer/football players, with 42 columns. 

We have a sizable set, with many classes, so we'll use knitr cacheing, and watch performance with `{tictoc}` and `{lineprof}` to get a sense of performance.

## Dependancies

```{R}
## CRAN
require("DALEX")
require("spinifex")
require("tourr")
require("ggplot2")
require("tictoc")
## Github
if(require("treeshap") == FALSE)
  devtools::install_github('ModelOriented/treeshap')
require("treeshap")
if(require("lineprof") == FALSE)
  devtools::install_github('hadley/lineprof')
require("lineprof")
## Local functions, esp. for basis_cheem() and view_cheem()
source("./apps/poc/trees_of_cheem.r")
if(F) ## Manualy run to view file:
  file.edit("./apps/poc/trees_of_cheem.r")
```

## Data setup

The column `overall` is an aggregate measure of current skill, we'll use this as the target variable, discard `nationality` and other potential target variables `potential`, `value_eur`, `wage_eur`. We normalize the remaining columns by their own standard deviation. 

Because of the column names having grouped naming, see the the first suffix of the measure names, _ie_ `attacking`, `skill`, `movement.` We have reasons to be concerned that the data may contain highly correlated variables. We suspect that the true dimensionality of the data is much less than 40. 

```{R}
raw <- DALEX::fifa
str(raw)

## Remove some columns
require("dplyr")
sub <- raw
sub <- sub %>%
  select(-c(`nationality`, `potential`, `value_eur`, `wage_eur`))

## Normalize each column by its standard deviations
sub <- spinifex::scale_sd(sub) %>% data.matrix()

## intrisic data dimensionality concerns; even the column names are grouped measures.
colnames(sub)
```

## Intrinsic Dimension Estimation

### Correlation

Thoughts: Goalkeeping clearly bloated and unique, first 15 or so dim also seem redundant as well as a chunk in the middle. Let's see what PCA scree plot looks like.

```{r}
#### 1) Correlation
require("corrplot")
tic("correlation")
cor_mat <- cor(sub)
corrplot(cor_mat,
         method = "circle", ## geom
         type = "upper", ## only upper triangle
         diag = F, ## remove auto correlation
         order = "AOE", ## Angle of eigenvectors
         tl.col="black", tl.srt=90, ## Text label color and rotation
         tl.pos = "td")
toc()
```

### PCA Screeplot

Looks like 20 dims add almost nothing. Eyeballing it, I would subjectively select 6 or 11 dimensions as elbows to approximate the data. Let's see how that compares to empirical estimates, powered by `{Rdimtools}`.

```{r}
#### 2) PCA
source("./apps/poc/ggproto_screeplot_pca.r") ## Load some local functions, designed for ML EDA
if(F)
  file.edit("./apps/poc/ggproto_screeplot_pca.r")

tic("PCA & scree")
pca_obj <- prcomp(sub)
palette(RColorBrewer::brewer.pal(8, "Dark2"))
ggplot2::ggplot() + ggproto_screeplot_pca(pca_obj) + ggtitle("PCA screeplot, fifa data")
toc()
```

### `{Rdimtools}` empirical estimations

Alright, not too shabby. For more empirical methods one might select 12 to 16 dimensions, but as the dimensionality increases the volume of the phase space (and thus viewing space of linear projections) increases exponentially. Additionally it looks like the the name suffix of the columns doesn't fit the order of the angle of the eigenvectors. In light of these two I am going to approximate the data with the first 6 Principal components. Unfortunately these are less interpretable than the column names, so the trick will be too convert components back to the original variable space.

```{r}
tic("Rdimtools IDE (only the faster tests).")
ide_vect(data = sub, inc_slow = FALSE)
toc()
dat <- pca_obj$x[, 1:6]
```


## Standard PCA

"We approximate our 42-dim data in just 6 PC, and visually look for clusters and outliers, wow"

```{r}
tic("ggpairs, first 6 PC")
GGally::ggpairs(as.data.frame(dat))
toc()
```

## Grand Tour, random bases

```{r}
str(dat)
t_array <- tourr::save_history(data = dat, max_bases = 10, ## number of random bases to use
                               tour_path = grand_tour())

tic("render grand tour animimation")
spinifex::play_tour_path(
  t_array, 
  angle = .2, ## Distance interpolated in radians
  axes = "left",
  render_type = render_plotly, ## or render_gganimate for a .gif
  identity_args = list(alpha = .1),
  ggproto = list(theme_spinifex(),
                 ggtitle("Grand tour, 10 rand bases, interp w/ angle = .2")
  )
)
toc()
```

## Guided Tour, simulated annealing on objective function

```{r}
tic("find cmass")
bas_cmass <- spinifex::basis_guided(dat, tourr::cmass())
toc()
tic("find holes")
t_array <- tourr::save_history(data = dat,
                               tour_path = guided_tour(holes()), 
                               start = bas_cmass)
toc()

tic("render guided tour")
spinifex::play_tour_path(
  t_array, 
  angle = .05, ## distance interpolated in radians
  axes = "left",
  render_type = render_plotly, ## or render_gganimate for a .gif
  identity_args = list(alpha = .1),
  ggproto = list(theme_spinifex(),
                 ggtitle("Guided tour, simulated annealing from cmass() to holes()")
  )
)
toc()
```


## Manual Tour, manipulate select variable
```{r}
bas <- spinifex::basis_half_circle(dat)

tic("render manual tour")
spinifex::play_manual_tour(
  bas, dat, manip_var = 4,
  angle = .1, ## distance interpolated in radians
  axes = "left",
  render_type = render_plotly, ## or render_gganimate for a .gif
  identity_args = list(alpha = .1),
  ggproto = list(theme_spinifex(),
                 ggtitle("manual tour, PCA is sensitive to the cluster, explore orthogonally")
  )
)
toc()
```


## Outlier detection

It has been some years before I regularly worked with people that follow soccer closely; I would be hard pressed to name players outside of Beckham and Messi. It was like pulling teeth to get suggestions from the lab, when asking for outliers, eventually I got `L. Suarez`. But I wanted a more empirical measure, Mahalanobis distance is fast and straightforeward, I'll grab a few names from there.

```{r}
maha_dist <-
  mahalanobis(sub, colMeans(sub), cov(sub)) %>%
  sort(decreasing = T)

head(maha_dist, n = 6L)
psych::outlier(sub, bad = )

## check the maha dist of our original name, 
.mh_nms <- names(maha_dist)
tgt_name <- "L. Messi"
tgt_name2 <- "L. Suarez"
.idx1 <- which(.mh_nms == tgt_name)
.idx2 <- which(.mh_nms == tgt_name2)
paste0(tgt_name, " has the ", .idx1, 
       "-th highest mahalanobis distance, a value with a value of ", 
       round(maha_dist[.idx1], 1), ".")
paste0(tgt_name2, " has the ", .idx2, 
       "-th highest mahalanobis distance, a value with a value of ", 
       round(maha_dist[.idx2], 1), ".")

## Highest distance:
paste0(.mh_nms[1], " has the  highest mahalanobis distance, a value with a value of ", 
       round(maha_dist[1], 1), ".")
tgt_nm <- .mh_nms[1]
```

## Find a Cheem basis

The basis_cheem function was based on classification supervised data, make have to add condition handling for the continuous case.

```{r, eval=FALSE}
## Apply to the most outlying obs.
.rn <- row.names(sub)
.idx1 <- which(.mh_rn == tgt_nm1)

{
  tic("basis_cheem()")
  cheem_bas <- basis_cheem(
    data = dat,
    class = clas,
    holdout_rownum = .idx1, 
    ## Selecting DALEX::predict_parts()
    parts_type = "shap", ## expects 'shap', 'break_down' or 'break_down_interactions'
    parts_B = 10,
    parts_N = NULL,
    ## Selecting spinifex::basis_*(), expects 'olda', 'pca', 'odp' or 'onpp'
    basis_type = "pca")
  toc()
  ## 1) raw: 127 sec, 
  ## 2) top 25% nationalities,(80% obs) 88sec, 
  ## 3) predicting `overall`, 
}
```

## View the starting basis

```{r, eval=FALSE}
##TODO: another error;
# Error in `[.data.frame`(df, setdiff(names(df), names(transformed))) : 
#   undefined columns selected
# In addition: Warning message:
# Duplicated aesthetics after name standardisation: 
### IIRC this is is the same issue that came up when trying to abstract spinifex functions...
# debugonce(view_cheem)
# debugonce(view_frame)
paste0("view_cheem: ", tgt_name)
view_cheem(cheem_basis = cheem_bas,
           show_parts = TRUE)
## ... passes to DALEX::plot.predict_parts()
```

## Cheem tour

### Short cheem tour, 4 target bases

```{r, eval=FALSE}
if(interactive())
  ?spinifex::play_tour_path()
## tour_path wants an array of target bases to tourr::interpolate() between.

## Let's naively find different cheem bases where SHAP is always on X and we find different first components for Y.
.bas_types <- c('pca', 'odp', 'onpp') ## 'olda'
tgt_bases <- array(NA, dim = c(dim(cheem_bas), length(.bas_types))) ## init
.mute <- sapply(seq_along(.bas_types), function(i){
  tgt_bases[,, i] <<-
    basis_cheem(dat, clas, oos_obs, oos_clas,
                ## X axis is always this SHAPely values
                parts_type = "shap",
                parts_B = 10,
                parts_N = NULL,
                ## Vary across components on Y axis, expects 'olda', 'pca', 'odp' or 'onpp'
                basis_type = .bas_types[i])
})
## Format for tourr::interpolate() 
tgt_bases <- as_history_array(tgt_bases, dat)

## Aesthetic init
.colorPal <- RColorBrewer::brewer.pal(8, "Dark2")
.col <- .colorPal[as.integer(clas)]
.col[holdout_obs] <- "red"
.shp <- as.integer(clas)
.shp[holdout_obs] <- 4 ## shape 8 is *
.alp <- rep(0.4, nrow(dat))
.alp[holdout_obs] <- .7
.siz <- rep(1.5, nrow(dat))
.siz[holdout_obs] <- 6

## Tour animation
spinifex::play_tour_path(
  tour_path = tgt_bases, 
  data = dat,
  ## position of the basis unit circle
  ## expects:  "center", "left", "right", "bottomleft", "topright", or "off"
  axes = "left", 
  angle = .15, ## step size distance between interpolation planes 
  fps = 8, 
  ## list that would go inside ggplot2::geom_point(aes(X))
  aes_args = list(), 
  ## list that would go inside geom, outside aes: ggplot2::geom_point(aes(), X)
  identity_args = list(color = .col, shape = .shp,
                       size = .siz, alpha = .alp),
  ## list of items to "add" to a ggplot() + X
  ggproto = list(spinifex::theme_spinifex()),
  ## expects render_gganimate (.gif) or render_plotly (.html widget)
  render_type = render_plotly,
  tooltip = c("id") ## only adds tool tips on axes segmetns not projection points.
)
## For saving, store output of spinifex::play_tour_path()
# ?gganimate::anim_save() ## with render_gganimate
# ?htmlwidgets::saveWidget() ## with render_gganimate
```
